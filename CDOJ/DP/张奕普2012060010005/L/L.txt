    n个路口由n-1条路连接即n个节点由n-1条边连接，符合树的定义，可用树形dp，用记忆化搜索写会比较方便。设dp[i][j]、num[i][j]，i为当前考虑的节点，j表示这个状态是否设置糖果发放点(0表示不放,1表示放)，dp为糖果发放点的最小个数，num为方案数，两个值考虑的都是以i为根节点的数。有如下的转移方程：
    1、当前节点没设置则它的子节点都要设置：
    dp[now][0]=sum(dp[temp][1]) （temp为now的子节点）
    num[now][0]*=num[temp][1]
    2、当前节点设置了则它的子节点可以设置也可以不设置，取其中的最小值，相等则两个都取：
    dp[temp][0]>dp[temp][1]：
        dp[now][1]+=dp[temp][1]
        num[now][1]*=num[temp][1]
    dp[temp][0]<dp[temp][1]：
        dp[now][1]+=dp[temp][0]
	num[now][1]*=num[temp][0]
    dp[temp][0]=dp[temp][1]：
	dp[now][1]+=dp[temp][0]
	num[now][1]*=(num[temp][0]+num[temp][1])
    最后糖果发放点的最小值是dp[0][1]、dp[0][0]，中的较小值，相等则方案数是两个的和，别忘记了取和后要余MOD。
    时间复杂度应该是O(n)了，取决于节点数。