    混合背包问题。
    设dp[i][j]为前i堆工作，j点时间时所能得到的最大快乐值，考虑一个堆是的dp则使用了重复利用数组的发放。
    s=0时至少要放一个，也就是说这是唯一一个影响结果是否输出-1的递推，因此递推这样的堆时把dp值都初始化为-INF。这样当dp[n][t]<0时就输出-1。
    至少放一个有两种可能，这个物品是这堆中第一个放的，可由dp[i][k-c[j]]推出，这个物品不是第一个放的，可由dp[i+1][k-c[j]]推出。
    因此转移方程为：dp[i+1][k]=max(max(dp[i+1][k],dp[i+1][k-c[j]]+g[j]),dp[i][k-c[j]]+g[j]);
    s=1时可以不放，所以可以把值都初始化为dp[i][j]。
    也有两种情况，这个物品放和这个物品不放，因为最多放一个所以都可以从上一堆的dp值推出
    转移方程为：dp[i+1][k]=max(max(dp[i][k],dp[i+1][k]),dp[i][k-c[j]]+g[j]);
    s=2是就是01背包问题了，也要把值都初始化为dp[i][j]。
    有dp[i+1][k]=max(dp[i+1][k],dp[i+1][k-c[j]]+g[j]);
    看主循环得时间复杂度为O(n*m*t)。