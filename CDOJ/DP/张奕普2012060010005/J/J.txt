    状压dp，假设从左上角开始放，当放置第(i,j)个格子时，由于只有横放和竖放两种，对于字典序小于(i,j)的格子肯定是已经放过的，而字典序大于(i,j)的格子是没放过的。因此唯一影响当前格子的只有每列从上往下第一个没放过的格子。这些格子与j值一一对应，它们的状态可以用一个长度为m的hash值存储，0表示没放，1表示放了。 
    从最后一个格子向左上方递推，横放的话上一个状态的第j+1个格子就不能放了,而且如果是一行的最后一个就不能横放所以j+1<w：dp[i][hash]+=dp[i-1][hash|(1<<j+1)];
    竖放的话上一个状态的第j个格子就不能放了,同上i+1<h：dp[i][hash]+=dp[i-1][hash|(1<<j)];
    状态转移方程就是上面两个。
    由于第i个状态只由第i-1个状态推出，可以用滚动数组来节省空间。
    由主循环看，时间复杂度是O(n*m*(1<<m)),最大为247808，符合要求。
    使用int数组输入11 11时是负值（溢出），改用longlong后ac。