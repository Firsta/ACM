    m>=n时，可以每个人都单独坐一个车厢，故可以直接输出0。
    m<n时，因为要求每个车厢的最大值和最小值的差值尽量小，一次可以先预处理，把n个值从小到达排列，之后就可以按顺序dp了。
    设dp[i][j]为前i个人分成j份的最小差值总和，由于分成j份可以先分成j-1份再将剩余的人装到一个车厢里，所以得状态转移方程:dp[i][j]=min(dp[k][j-1]+(a[i]-a[k+1])^2) (k<i)
    如果就这样递推时间复杂度为O(m*n^2)，肯定会超时，所以需要优化。
    观察转移方程，可以化为：2*a[i]*a[k+1]+dp[i][j]-a[i]^2=dp[k][j]+a[k+1]^2
    令k=2*a[i]、x=a[k+1]、b=dp[i][j]-a[i]^2，y=dp[k][j]+a[k+1]^2    a[i]是确定的所以要使dp[i][j]最小要使b最小，即截距最小，而在i确定是x，y只与k（中括号里的）相关，故可以应用斜率优化。
    回忆斜率优化，k单调递增时可以维护一个下凸的曲线，用单调队列维护，每添加一个新元素时从队尾维护，每遇到一次队列的最后两个节点q[r-1],q[r-2]与新元素分别表示的直线的斜率为小于关系时，就可以r--了。（元素对应的点即满足x=a[k+1]、=dp[k][j]+a[k+1]^2的点）
    至于头部的话，因为有dp[u][j]+a[i]^2+a[u+1]^2-2*a[i]*a[u+1]<dp[k][j]+a[i]^2+a[k+1]^2-2*a[i]*a[k+1]时可得包含斜率表达式的不等式：{(dp[u][j]+a[u+1]^2)-(dp[k][j]-a[k+1]^2)}/{a[u+1]-a[k+1]}<2*a[i]，此时u表示的节点明显更优，所以可以从头部开始两个两个比较，如果有上述不等式成立则，h++。
    每一个i都维护一个新的单调队列。时间复杂度降到O(n*m)，因为每次从单调队列取元素和加元素都近似O(1)。