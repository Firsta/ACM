    由于帮助的同学是有先后顺序的，所以与最大k乘积问题类似，只不过由段所构成的数改成了段中各个数的总和。
    dp[i][j]为考虑前i个同学分成j段所能得到的最大乘积，状态转移方程为：dp[i][j]=max(dp[i][j],dp[k][j-1]*sum[k+1][i])，sum[i][j]是从i到j的子段和。前i个数分成一段只有一种方法，所以dp[i][1]初始化为sum[0][i]。
    得到所以的sum值需要O(n^2)的时间复杂度，n^2>=n*m因此总的时间复杂度是O(n^2)，不过单看主要的算法是O(n*m)。
    如果这题不考虑先后顺序，感觉需要用到状压，有待思考。