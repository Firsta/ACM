Problem A. 棋盘

[Solution]
我们先思考一个经典的问题。
两个人在一张圆桌上玩游戏，两人需要轮流在桌子上放下一枚硬币，每次硬币的位置不能与之前的硬币相交，无法放置硬币的一方失败，问谁将获得最后的胜利。

事实上这道题目很简单，先手只需要把第一枚硬币放到圆桌的中心，那么无论后手在什么位置放硬币，先手只要放在关于中心的对称位置即可。也就是说，只要后手能够放下硬币，先手一定存在放下硬币的方法，所以先手必胜。

我们用同样的思路思考这道题目：

1、当棋盘的长宽均为偶数时，这个棋盘存在一个中心点（注意是中心点，不是中心格子），这时，无论先手怎样选择矩形染色，后手一定可以在先手选择矩形位置的对称位置找到一个相同大小的矩形染色，因而在这种情况下后手必胜。

2、当棋盘的长宽有一个是奇数时，先手的第一步可以选择将棋盘的中心格子染色。之后无论后手怎样选择矩形位置，先手将以同样的方式找到相应的对称矩形，最终获得游戏的胜利。

基于以上分析，代码的实现非常简单。

Problem B. P酱的冒险旅途

[Solution]
假如我们换一个问题，你需要使用UDLR四种字符，构建一种从起点走到出口的最短行走路径，你会怎么构造呢？至少我们可以确定的是，LR两种字符绝不可能同时出现在你构造出的序列，UD同理。这是因为，如果其中一种行走方向能够缩短到出口的距离，那么另一种方向一定会起到反作用，事实上我们有更强的结论，四种字符在最优序列中的出现次数一定是固定不变的，原因留给大家思考。

基于以上分析，本题的策略就是“在某个方向选择行走而不是停留，当且仅当行走能够缩短P酱与出口的距离”，这里的“距离”有一个专有的称呼，称为曼哈顿距离（Manhattan Distance)，它的定义是两点间横坐标差的绝对值与纵坐标差的绝对值之和，即 |dx| + |dy|。

标称给出了一种基于以上分析的相对简洁的实现方法，供大家参考。

[Others]
可以看出，这道题目在比赛中，甚至很多集训队的老队员的前几次提交都得到了Wrong Answer的结果，1次通过的人数也非常少。很大一部分原因是因为我在前几天把题目加到OJ上是临时添加的一组数据，这组数据被放在了测试数据的第一组：
0 0 8
LRUDLRUD

答案是0。

这种情况一般称为“边界条件”，也就是一些特殊的情况，而这种情况又是完全合法的，满足Input的所有要求，这就需要大家更加细心的处理好自己的程序，即使一组数据出错，在比赛中也是不能得到AC的。

Problem C. 倒推数组

[Solution]
一道很奇怪的题目，题目本身事实上已经基本给出了算法的实现。

首先观察可以发现，数列中各元素的顺序不会影响f()函数的值，为了字典序最小，最终的答案必然是从小到大排成一排的。

那么根据公式，最小的元素在答案中会被累加的次数是2n-1次，次小的元素是2n-3次，这种累加的总值我们称之为对答案的“贡献”。

我们要构造最小字典序的解，那么前n-1个数最小分别是多少呢？对了！就是1,2,3,...,n-1, 同时，这n-1个数对答案的贡献已经尽可能小了，也就是说第n个数的值已经尽可能大了，如果这种情况下第n个数还是小于等于n-1，那么显然答案是无解的，否则我们就已经成功构造出了最终的答案。

[Others]
本题可以换成这样一道题，我们把对数列的要求换成：
1、数列必须从小到大排成一排
2、数列中每个元素互不相同。
3、数列由n个正整数构成，f(a) = F。

求满足条件的字典序最大的序列，留给有兴趣的同学思考。


Problem D. 方方是个坏孩子

[Solution]
题目的要求重新表述如下：
给定数列 a[1], a[2], ... a[n], 寻找一段连续的序列[L, R]，使得 (a[L] + a[L + 1] + ... + a[R]) mod P = 0，这里 mod 是取模操作，即C和Java中的运算符%。
求最长的序列，即R-L+1的最大值，无解输出1。

首先引入前缀和(Prefix Sum)的概念：

定义 sum[i] = (a[1] + a[2] +... + a[i]) 称为i位置的前缀和。 (1 <= i <= n)，特别的有sum[0] = 0。

那么如果某段连续的[L, R]满足条件，即元素之和为P的倍数，那么一定有以下结论成立：

(sum[R] - sum[L - 1]) % P = 0，易证此条件是充要的。

换言之，问题变为，求相隔最远的L和R，满足 sum[L - 1] 和 sum[R]在模P域下相等，即sum[L - 1] % P == sum[R] % P。 (1 <= L <= R <= n)

由于P很小，不超过11，我们开一个长度为P的数组front[P] 和 rear[P], front[i]代表最小的下标x，使得sum[x] % P = i，rear[i]则代表最大的下标x满足相同的条件。枚举答案即可。

[Others]
这种把一段区间的问题转换为两段前缀问题的思路在竞赛中非常常见，例如字符串RK Hash的算法(RabinCKarp algorithm),或者树状数组(Binary Indexed Tree)对区间求和的方法，都应用了这种转化的思想。

两个思考：

1、能否只使用一个数组实现front和rear两个数组完成的任务？（提示：参考标程）

2、由于P很小，我们可以开数组记录每个值对应的下标，如果P很大(如10^9规模)，有没有好的办法求解呢？

Problem E. LoveZx与期末考试

[Solution]
显然A和B很大，我们需要用字符串读入两个数。

假如LoveZx和Zx的成绩位数不同，那么两者之间的大小关系是不会改变的，这种情况可以提前判断。
于是接下来的讨论都在位数相同的前提下进行：

很自然的，我们从高到低分析每一位：
设当前位Zx的值为up，LoveZx的值为down，那么up和down的大小关系有三种：

一、up < down，出现这种情况说明Zx的分数已经小于LoveZx的分数了，此时LoveZx不需再作任何改动。
二、up > down，这时LoveZx必须对他的分数作修改，也就是从后面还没有选择的位置中挑一个数，放到这个位置来，同时其它数字右移，显然我们希望这个数字越大越好。
这里有三种可能：
1.可以挑选的最大数字比up大，这时LoveZx只要把这个数字移过来，任务就完成了，不需再做任何改动。
2.可以挑选的最大数字比up小，这时说明无解，LoveZx的分数已经不可能超过Zx了。
3.可以挑选的最大数字等于up，这时LoveZx需要把这个数字移过来，但是任务还没有完成，我们还需要继续分析后面的位置。注意到这种情况下，选择尽可能靠后的数字更优。
三、up == down，这时如果后面有大于up的数字以供挑选，把那个数字移过来将成为一组合法的解，虽然我们无法保证这个解是最优的，但是可以用来更新答案。
我们也可以选择不做任何改动，继续分析后面的位置。

以上是分析的思路，下面我们讨论具体的实现：

我们用一个循环，从高到低枚举每一位，同时维护一个变量tot，代表当前进行了几次移位操作，一个变量ans，代表最后的答案。

对于每一位：
up < down: 直接跳出循环
up > down： 
如果可以挑选的最大数字比up大，tot加一，用tot更新ans，跳出循环。
如果可以挑选的最大数字比up小，直接跳出循环。
如果可以挑选的最大数字等于up，选在最靠后的一个数字，移动到前面来（这里移动不能直接模拟，会超时，稍后讨论怎样移动），tot加一，继续下一次循环。

up == down:
如果后面有大于up的数字，使用(tot+1)更新ans，但是并不修改tot的值，因为这只是一种可能性。
继续下一次循环。

最后，如果ans从未被更新，说明无解，否则输出ans。

现在我们讨论怎样快速定位可以挑选的最大数字，同时讨论怎样快速移动这个数字。

关于这个问题，出题人本身写了两份解题报告，在附件中给出，大家可以参考。下面列出第二种做法：

令Zx的成绩为字符串A，LoveZx的成绩为字符串B，我们可以设一个变量cnt指向当前B中与A[i]比较的那一位，同时统计出B[cnt]之后还有每一位数（0，1，2，3，……，9）还各有几个counts[0], counts[1],…. counts[9],。如果遇到需要移动的情况，就把需要移动的数的数目减去即可。这样就可以避免模拟的情况出现。

[Others]
这道题目涉及到的地方很多，对于完全初学毫无基础的新人来说，可以先部分理解这道题目，比如，如果题目的规模是A, B <= 10^1000,这时直接模拟移位是可行的，那么之前的分析过程能否理解？至于后面的部分，没有必要拘泥于标程的写法。

另外，由于我们提供了标程，大家也可以自己生成一些小数据，分别将自己的程序和标程运行这些数据，通过结果的比较找到自己的错误。
