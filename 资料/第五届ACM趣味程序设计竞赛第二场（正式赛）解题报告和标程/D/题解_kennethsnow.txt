Problem D. 方方是个坏孩子

[Solution]
题目的要求重新表述如下：
给定数列 a[1], a[2], ... a[n], 寻找一段连续的序列[L, R]，使得 (a[L] + a[L + 1] + ... + a[R]) mod P = 0，这里 mod 是取模操作，即C和Java中的运算符%。
求最长的序列，即R-L+1的最大值，无解输出1。

首先引入前缀和(Prefix Sum)的概念：

定义 sum[i] = (a[1] + a[2] +... + a[i]) 称为i位置的前缀和。 (1 <= i <= n)，特别的有sum[0] = 0。

那么如果某段连续的[L, R]满足条件，即元素之和为P的倍数，那么一定有以下结论成立：

(sum[R] - sum[L - 1]) % P = 0，易证此条件是充要的。

换言之，问题变为，求相隔最远的L和R，满足 sum[L - 1] 和 sum[R]在模P域下相等，即sum[L - 1] % P == sum[R] % P。 (1 <= L <= R <= n)

由于P很小，不超过11，我们开一个长度为P的数组front[P] 和 rear[P], front[i]代表最小的下标x，使得sum[x] % P = i，rear[i]则代表最大的下标x满足相同的条件。枚举答案即可。

[Others]
这种把一段区间的问题转换为两段前缀问题的思路在竞赛中非常常见，例如字符串RK Hash的算法(RabinCKarp algorithm),或者树状数组(Binary Indexed Tree)对区间求和的方法，都应用了这种转化的思想。

两个思考：

1、能否只使用一个数组实现front和rear两个数组完成的任务？（提示：参考标程）

2、由于P很小，我们可以开数组记录每个值对应的下标，如果P很大(如10^9规模)，有没有好的办法求解呢？
